---
title: 比特币原理概述
description: 对比特币基本原理进行理解
categories:
 - 区块链
tags:
---

# 引言

在区块链技术的应用中，比特币应该算是当前应用最广、影响力最大的应用，现在我们就来探究一下其基本的运行原理。

还记得区块链技术最基础的几个特点吗？

> 1. 非安全环境下的分布式数据库
> 2. 采用密码学来保证数据安全
> 3. 使用共识算法对新增数据达成共识

下面将就这几个特点在比特币中的体现做一个基本介绍。

# 比特币原理概述

## 非安全环境下的分布式数据库

### 非安全环境

比特币在设计之初就考虑了如何应对非安全节点的问题。作为一个本质上的数据库，能够造成危险的点主要有两个：

1. 已经存在的数据的修改
2. 伪造数据的存入

如比特币系统的核心数据：交易。每个交易都有一个收款人、一个付款人、交易金额。那么可能被攻击的点在于：对于已经被承认并记录在案的交易，篡改其收款人或交易金额来牟利；直接伪造一笔交易。

为了防止这种情况，比特币有如下机制：

1. 后一个区块保存前一个区块的Hash值
2. 只有最长的链条才能得到承认
3. 使用算力证明(pow)共识算法来保证新加入数据未被伪造

<!-- todo: 放区块链的图 -->

因此，要篡改比特币的记录，必须比全网其他所有节点都要算得快，即拥有至少51%的算力，这就是"51%攻击"。

### 分布式

<!-- 比特币的节点类型，比特币节点加入与离开的方法 -->
作为一个分布式的系统，比特币系统由很多节点组成。这些节点由4个基本功能组合而成：**钱包**、**矿工**、**区块信息**、**网络路由节点**。

其中，每个节点都具有的功能是**网络路由节点**，即每个节点都参与验证并传播交易及区块信息，发现并维持与对等节点的连接。

**区块信息**分为完整的区块信息和不完整的区块信息。有一些节点拥有完整的区块信息，这种节点被称为"**全节点**"。全节点能够独自自主的完成所有的交易校验。一些节点只保留了部分区块信息，这样的节点被称为"**SPV节点（轻量级节点）**"，它们使用简易支付验证(SPV)来完成交易验证。

**矿工**是指运行工作量证明(pow)算法的节点，这些节点通过相互竞争的方式来创建新的区块。这些节点有的保存了完整区块链信息，可以独立参与挖矿工作，有的没有保存完整区块链信息，挖矿依赖于矿池服务器,这种组合被称为"**矿池**"。一个矿池是由一个全节点（矿池服务器）与它背后连接着的众多轻量级节点组成的。挖矿这一行为实际就是将一段时间内发生的所有交易打包保存到区块中使之不能被更改。交易在该过程中会被校验是否通过，未通过的交易会被放弃，因此比特币的交易确认需要一定的时间。新增的区块会给与生成该区块的矿工一定的比特币奖励，这也是比特币的唯一来源。区块生成后会在全网进行同步，全节点会对其进行保存。

**钱包**一般是桌面比特币客户端。该节点可以进行交易。用户的身份信息，公钥和私钥的解密加密都属于钱包功能。通过使用公钥和私钥，能够对用户的现实身份进行保密。

比特币网络中一般具有比特币协议、Stratum协议和矿池挖矿协议。它们的组成关系用《《精通比特币》》中的一张架构图来展示。

![比特币架构图](http://8btc.com/data/attachment/portal/201505/29/135734wtwzoomwgbf2a4zb.png)

这中间有几个身份，这就是比特币网络上节点的几个类型。

* 比特币核心客户端

比特币核心客户端包含了钱包、矿工、完整区块链和网络路由节点四大功能，可以用作所有用途。开发者也一般运行核心客户端来对比特币进行开发和测试。

* 全节点客户端

全节点客户端代表储存了完整区块链网络的客户端，可能具有挖矿和钱包功能。这种客户端是比特币网络的骨架，该客户端越多，比特币网络越稳定。

* 独立矿工

独立矿工一般都使用全节点客户端，能够自主进行挖矿。如果成功生成了区块将获得奖励，否则没有收获。

* Stratum网络

Stratum网络由Stratum中心服务器、Stratum挖矿和瘦客户端钱包组成，本质是一个矿池。Stratum矿机和Stratum服务器通过使用Stratum协议进行连接，瘦客户端兼具Stratum服务器功能。Stratum服务器会暴露在比特币网络中。Stratum网络下的矿工对Stratum中的交易确认会更有效率。Stratum网络中，最大的好处在于矿工可以从Stratum中心服务器中获取区块链信息，不用本地保存完整区块链。所有矿工被视为一个整体，若生成新的区块那么奖励的比特币将直接放入Stratum中心服务器，再由该服务器按照各个矿工的算力情况对奖励进行分配。比起独立矿工来说更大程度上能够保证取得收获。

* 矿池和矿池矿工

矿池是一种算力的组织形式，它通过中心矿池服务器将所有矿池矿工的算力组合起来形成更强的算力，以此来获得更多的比特币。获取的比特币再由矿池服务器按照一定规则分配给为矿池提供算力的矿池矿工。可以将矿池看作一个运行在比特币网络上的子区块链。矿池之间一般使用自定义的矿池算法来进行算力分配。

* 边缘路由器

许多大型公司基于比特币作了很多应用，比如交易所、钱包、区块浏览器、商家支付处理等业务，这些应用接入比特币网络的跳转服务器往往不具备挖矿和钱包的功能，它们只负责网络的接入以及对完整区块的储存。这些服务器就被称为"边缘服务器"。它们往往处于比特币网络连接其他应用的边缘地带。

* SPV钱包

SPV钱包是比特币网络中最多的部分，它们基本都是用户在使用。由于完整区块链比较大，在手机等应用场所不是很方便，因此这类钱包不具有完整的区块链，只保留了交易和网络节点的功能。因为自身没有完整的区块链，因此在查询自身资金状况时需要向全节点询问(详见数据库部分)。同时，如果有人向钱包账户转账，全节点会在确认后将交易信息和验证方式告诉钱包，钱包在做验证之后才算确认交易。

### 数据库

<!-- 比特币的数据结构 -->
比特币本质上是一个数据库。既然是数据库，那么它就有一定的存储结构。现在我们来看看比特币涉及到的数据结构。

* 比特币

这应该是一个非常重要的问题了。大家都在说比特币，我们讨论区块链也绕不开比特币，那么比特币到底是什么？它有怎样的数据结构？它是怎么在用户账户中表示的？我们是根据什么过程来进行交易的呢？

其实在比特币网络中，**没有比特币**，**没有比特币**，**没有比特币**。

*比特币只是为了方便人们理解而提出的一个**概念***。

**比特币不是一个实体**。

中本聪这一设计是一个非常天才的设计，它解决了账户分布式管理的问题。下面我们来看一看比特币具体是怎么回事。

一般来说，当我们设计一个涉及到金额这种有数字的系统，我们一般都会设计一个抽象概念：**账户**，它一般会在数据库中占据一张表。比如ABC三个人，每人账户里都有100块钱。现在A要付50元给B，那么一般的设计中，需要做以下几件事：

1. 检查A账户的余额是否大于50
2. 从A账户减去50
3. 在B账户加上50

整个过程中，需要保证形成数据库事物，运行中任意一步出了错都要进行回滚。现在一般的IT采用的都是这种方法，简单而好用。

但是现在将数据库放入分布式环境，以上过程就会有问题发生了。

首先，账户的余额必须要及时更新。这不仅意味着对网速的要求，更意味着每个节点都必须能够进行短时间大量的IO操作，而且需要考虑如何实现对资源加锁以保证在网络延迟的情况下账户余额的正确性。

其次，如何保证该体系下数字正确而不被篡改？账户的余额意味着发生变动，如何知道所有的变动合法或不合法？可以通过区块链来保留每一笔交易记录，使用密码学来保证区块链中数据不能被改变。那么，长久来看，区块链的数据量将越来越庞大，其中有大量的曾经的交易数据是事实上的冗余数据，但如果将其删除则无法证明账户余额的合法性。

针对这一问题，中本聪提出了一个方案：**未经使用的交易输出(Unspent Transaction Output，UTXO)**(ps:比特币社区往往将交易transaction简写为TX)。即：每笔交易的输入都是某些交易的输出。

为了方便理解，还是使用ABC三个人作个例子。

1. A是矿工，算出了一个新的区块，因此得到了系统的奖励：50比特币。这是第一笔交易，被称为"**Coinbase**"。此时交易的输入就是系统给与。

<!-- 放置图片:UTXO-1 -->

2. B是一个商家，与A达成了一笔交易，A需要支付20比特币。这时，会将上一步达成的交易变成输入，输出两笔，分别是指向B的20比特币和指向A的30比特币。其中指向A的比特币被称为找零。

<!-- 放置图片:UTXO-2 -->

3. C向A和B各借了5比特币。此时，上一步的输出将会变成这一次的输入。最后输出3笔，指向C的10比特币、指向A的25比特币和指向B的15比特币。

<!-- 放置图片:UTXO-3 -->

以上过程就是比特币UTXO的运行原理。

可以清楚的发现，**比特币中没有*账户*这一概念**。当我们需要知道某人还有多少余额时，其实是读取了所有的交易过程并计算出了未使用的数字。所有的交易的输入都是未被使用过的交易输出，如果数额不符则将多余的部分以输出找零的方式返回给付出账户。

这一解决方案比起记录账户余额来说有很多优点。首先，各节点只需要对交易进行验证和记录，不需要对数字进行计算保证了不会因为并行操作导致某些操作被覆盖因而数字不正常。其次，**只需要保存每一条交易链条上最后一笔交易就可以计算出账户的余额**，为清除区块链长期运行下产生的冗余数据提供了方案。

所有未被使用的、指向该账户的交易输出值的和，就是该账户的比特币余额。

* 交易

在比特币源码目录`src\primitives\transaction.h`中定义了交易的数据结构。

一个交易对象，包含以下结构：

|   大小   |   字段   |   描述   |
|:---:|:---:|:---:|
|   4字节  |  版本    |明确这笔交易参照的交易规则版本|
| 1-9字节  |  输入数量 | 被包含的输入数量 |
|   不定   | 输入列表  | 一个或多个交易输入 |
| 1-9字节  | 输出数量  | 被包含的输出数量  |
|   不定   | 输出列表  | 一个或多个交易输出 |
|  4字节   | 锁定时间  | 一个UNIX时间戳或区块号 |

> 交易的锁定时间是指该交易能够被加入到区块链中的最短时间。当它为0时表示可以被立即加入到区块链中。如果该值大于0且小于5亿，该值被视为区块高度，在区块达到这个高度之前交易不会被记录到区块链中。如果该值大于5亿，则被视为Unix时间戳，在未到达该时间点之前该交易不会被加入到区块链中。
>
> 该值一般用于将交易的生效时间予以延后。

交易诞生于它被创建的那一刻，随后会被一个或多个签名加密，这些签名标志着对该交易指向的比特币资金的许可。接下来，该交易会被广播到比特币网络中。每一个节点接到交易之后都会对其进行验证，验证通过之后节点会对其进行广播，因此一个交易在比特币网络中传播是越来越广和越来越快的，直到该交易被网络中大多数节点接收。

最终，交易来到了矿工节点，加入了矿工的交易池。

* 交易池

当交易被广播至矿工节点时，矿工会将交易加入本地交易池中。每个矿工会对交易进行限制，保证交易数量不会过多，一般会根据交易费用（手续费）来排序，保证自己获得最多的手续费。

在`src/policy/fees.h`中可以看到交易池的数据结构。其中**CTxMemPoolEntry**是交易池中交易的数据结构，**CTxMemPool**是交易池本身的数据结构。

* 区块

矿工根据一定顺序，在交易池中取一定量的交易将其打包成区块。第一个成功生成区块的矿工将获得系统奖励。区块奖励从每个50比特币，每经过21万个区块减半一次，最终不再奖励比特币，使比特币总数约为2100万个。因为奖励越来越少，所以交易手续费越来越重要，这使得矿工需要谨慎考虑自己要打包的交易数量，而不会尽可能少的打包交易。

当交易被打入区块时，这笔交易就真正成立了。只有加入到区块中的交易才能被系统的其他节点认可。

在`src/primitives/block.h`中能够看到区块的数据结构。

## 采用密码学保护数据安全

比特币通过Hash函数和最长链机制的使用来保证数据安全。

* Hash函数

<!-- 比特币头部图 -->

可以看到，在区块链条中，后一个链包含了前一个链的Hash值。如果前一个区块中数据被篡改，则Hash值会发生变化。因此，这样可以保证前一个区块中的内容未被篡改。

* 最长链机制



## 使用共识算法对新增数据达成共识